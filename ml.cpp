#include "Arduino.h"
#include "ml.h"
#include "model.h"

#include <eloquent_tensorflow_cortexm.h>

/* ========================================== OPTIONS ========================================== */
#define READABLE_SENSOR_OUTPUT 1    // The output of the sensors will be printed to the Serial Monitor as comma seperated values
#define NORMALIZED_SENSOR_OUTPUT 1  // The output of the sensors will be normalized and will be printed to the Serial Monitor as comma seperated values
#define RUN_ML 1                    // Whether or not to run the model, will output the preduciton generated by the model. Can be useful to disable to get data faster

#define NUMBER_OF_INPUTS 198        // Number of inputs for the first layer of the model, defined also by how many values we pass to the model when we train it
#define NUMBER_OF_OUTPUTS 3         // Number of outputs for the last layer of the model, defined also by how many classifications we have
#define ARENA_SIZE 10000            // The size of the memory arena for the TensorFlow library, mostly a guess and check value
#define NUM_OPS 2                   // The number of operations in the model

char* classifications[] = { "palmdown", "pinkythumb", "extend" };   // The classifications of the model
float iqr = 42.12;                                                  // The interquartile range of the normalizaiton function, outputed when you train the model
float median = 31.01;                                               // The median of the normalizaiton function, outputed when you train the model

using Eloquent::CortexM::TensorFlow;    // The TensorFlow library for the Arduino
TensorFlow<NUM_OPS, ARENA_SIZE> tf;     // The TensorFlow object

/* ========================================== FUNCTIONS ========================================== */
/**
 * Setup the model for the Arduino. Only call this once in the setup function.
 * */
void setupML() {
    tf.setNumInputs(NUMBER_OF_INPUTS);      // Set the number of inputs for the model
    tf.setNumOutputs(NUMBER_OF_OUTPUTS);    // Set the number of outputs for the model
    tf.resolver.AddSoftmax();               // Add the softmax operation to the model. This is one of the two number of operations
    tf.resolver.AddRelu();                  // Add the relu operation to the model. This is one of the two number of operations

    while (!tf.begin(emg_model).isOk()) {   // Begin the model, if it fails, print the error
        Serial.println(tf.exception.toString());
    }
}

/**
 * Flatten the input into a single array. The input is a multitude of single dimensional arrays and two doubles. The first double is the major peak of the first array, the second double is the major peak of the parabola of the first array.
 * This must be done because the model only accepts a single array of inputs. Also remember to free this function after your done.
 * Somethings to note, the order in the output array is decided by however the data was outputted in the SENSOR_OUTPUT section in the main file. Without recreating this order in the array you'll just get garbage out.
 * Also this assumes that you have the correct number of inputs in each array. If you don't the program can crash or you'll get garbage out.
 */
float* flattenInput(double vReal1[], double majorPeak1, double majorPeakParabola1,
                    double vReal2[], double majorPeak2, double majorPeakParabola2,
                    double vReal3[], double majorPeak3, double majorPeakParabola3) {
    
    float* input = (float*)malloc(NUMBER_OF_INPUTS * sizeof(float));    // Allocate the memory for the input array which then will be returned
    if (input == NULL) {    // If the memory allocation fails, print an error
        Serial.println("Failed to allocate memory!");
        return NULL;
    }

    int vReal1Length = sizeof(vReal1) / sizeof(vReal1[0]);  // Get the length of the first array
    int vReal2Length = sizeof(vReal2) / sizeof(vReal2[0]);  // Get the length of the second array
    int vReal3Length = sizeof(vReal3) / sizeof(vReal3[0]);  // Get the length of the third array

    /**
     * Loops over the first three arrays and adds the values to the input array. Then adds the major peaks and the major peak parabolas to the input array.
     */
    int i = 0;
    while (true) {
        if (i < vReal1Length) input[i++] = (float)vReal1[i];
        else if (i < vReal1Length + vReal2Length) input[i++] = (float)vReal2[i - vReal1Length];
        else if (i < vReal1Length + vReal2Length + vReal3Length) input[i++] = (float)vReal3[i - vReal1Length - vReal2Length];
        else break;
    }

    input[i++] = (float)majorPeak1;
    input[i++] = (float)majorPeakParabola1;

    input[i++] = (float)majorPeak2;
    input[i++] = (float)majorPeakParabola2;

    input[i++] = (float)majorPeak3;
    input[i++] = (float)majorPeakParabola3;

    return input;
}

/**
 * Normalize the input array. This is done by subtracting the median from each value and then dividing by the interquartile range.
 * This is done because for some reason this is the best for accuracy on an older test data set, should recompile a new dataset and verify that this is true.
 * Note that the row is modified in place.
 */
void normalize(float* row, int length, float median, float iqr) {
    for (int i = 0; i < length; i++) {
        row[i] = (row[i] - median) / iqr;
    }
}

/**
 * Execute the model with the input array. This will print the classification and the time it took to run the model.
 */
void executeML(float* input) {
	if (!tf.predict(input).isOk()) {   // If prediction fails print the error
        Serial.println(tf.exception.toString());
        return;
    }

    Serial.print("classification: ");
    Serial.println(tf.classification);

    Serial.print("It takes ");
    Serial.print(tf.benchmark.microseconds());
    Serial.println("us for a single prediction");
}

/**
 * Run the machine learning model with the input arrays. This will print the input arrays, the normalized input arrays, and the classification of the model.
 */
void runML(double vReal1[], double majorPeak1, double majorPeakParabola1,
           double vReal2[], double majorPeak2, double majorPeakParabola2,
           double vReal3[], double majorPeak3, double majorPeakParabola3) {

    float* input = flattenInput(vReal1, majorPeak1, majorPeakParabola1,
                                vReal2, majorPeak2, majorPeakParabola2,
                                vReal3, majorPeak3, majorPeakParabola3);

    if (input == NULL) {    // The memory allcation issue that can come from flattenInput will have already been printed to screen.
        return;
    }

    if (READABLE_SENSOR_OUTPUT) {       // If the option is enabled, print the input array
        Serial.print("Readable: ");
        for (int x = 0; x < NUMBER_OF_INPUTS; x++) {
            if (x < NUMBER_OF_INPUTS - 1) {
              Serial.print(input[x]);
              Serial.print(", ");
            }
            else Serial.println(input[x]);
        }
    }

    normalize(input, NUMBER_OF_INPUTS, median, iqr); // Normalize the input array, modifies the actual input array.

    if (NORMALIZED_SENSOR_OUTPUT) {     // If the option is enabled, print the normalized input array
        Serial.print("Normalized: ");
        for (int x = 0; x < NUMBER_OF_INPUTS; x++) {
            if (x < NUMBER_OF_INPUTS - 1) {
              Serial.print(input[x]);
              Serial.print(", ");
            }
            else Serial.println(input[x]);
        }
    }
    
    if (RUN_ML) {   // If the option is enabled, run the model
        executeML(input);
    }

    free(input);    // Free the memory allocated for the input array

